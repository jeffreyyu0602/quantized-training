// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: param.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_param_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_param_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_param_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_param_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_param_2eproto;
namespace codegen {
class Argument;
struct ArgumentDefaultTypeInternal;
extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class BoolList;
struct BoolListDefaultTypeInternal;
extern BoolListDefaultTypeInternal _BoolList_default_instance_;
class IntList;
struct IntListDefaultTypeInternal;
extern IntListDefaultTypeInternal _IntList_default_instance_;
class Memory;
struct MemoryDefaultTypeInternal;
extern MemoryDefaultTypeInternal _Memory_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class OpOverload;
struct OpOverloadDefaultTypeInternal;
extern OpOverloadDefaultTypeInternal _OpOverload_default_instance_;
class OpOverloadList;
struct OpOverloadListDefaultTypeInternal;
extern OpOverloadListDefaultTypeInternal _OpOverloadList_default_instance_;
class OpOverload_KwargsEntry_DoNotUse;
struct OpOverload_KwargsEntry_DoNotUseDefaultTypeInternal;
extern OpOverload_KwargsEntry_DoNotUseDefaultTypeInternal _OpOverload_KwargsEntry_DoNotUse_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class ScalarList;
struct ScalarListDefaultTypeInternal;
extern ScalarListDefaultTypeInternal _ScalarList_default_instance_;
class ScratchpadInfo;
struct ScratchpadInfoDefaultTypeInternal;
extern ScratchpadInfoDefaultTypeInternal _ScratchpadInfo_default_instance_;
class Tensor;
struct TensorDefaultTypeInternal;
extern TensorDefaultTypeInternal _Tensor_default_instance_;
class TensorList;
struct TensorListDefaultTypeInternal;
extern TensorListDefaultTypeInternal _TensorList_default_instance_;
}  // namespace codegen
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace codegen {

// ===================================================================


// -------------------------------------------------------------------

class ScratchpadInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.ScratchpadInfo) */ {
 public:
  inline ScratchpadInfo() : ScratchpadInfo(nullptr) {}
  ~ScratchpadInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ScratchpadInfo(::google::protobuf::internal::ConstantInitialized);

  inline ScratchpadInfo(const ScratchpadInfo& from)
      : ScratchpadInfo(nullptr, from) {}
  ScratchpadInfo(ScratchpadInfo&& from) noexcept
    : ScratchpadInfo() {
    *this = ::std::move(from);
  }

  inline ScratchpadInfo& operator=(const ScratchpadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScratchpadInfo& operator=(ScratchpadInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScratchpadInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScratchpadInfo* internal_default_instance() {
    return reinterpret_cast<const ScratchpadInfo*>(
               &_ScratchpadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ScratchpadInfo& a, ScratchpadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ScratchpadInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScratchpadInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScratchpadInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScratchpadInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScratchpadInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ScratchpadInfo& from) {
    ScratchpadInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ScratchpadInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.ScratchpadInfo";
  }
  protected:
  explicit ScratchpadInfo(::google::protobuf::Arena* arena);
  ScratchpadInfo(::google::protobuf::Arena* arena, const ScratchpadInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 2,
    kBankFieldNumber = 1,
  };
  // uint64 offset = 2;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // int32 bank = 1;
  void clear_bank() ;
  ::int32_t bank() const;
  void set_bank(::int32_t value);

  private:
  ::int32_t _internal_bank() const;
  void _internal_set_bank(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:codegen.ScratchpadInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t offset_;
    ::int32_t bank_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class ScalarList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.ScalarList) */ {
 public:
  inline ScalarList() : ScalarList(nullptr) {}
  ~ScalarList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ScalarList(::google::protobuf::internal::ConstantInitialized);

  inline ScalarList(const ScalarList& from)
      : ScalarList(nullptr, from) {}
  ScalarList(ScalarList&& from) noexcept
    : ScalarList() {
    *this = ::std::move(from);
  }

  inline ScalarList& operator=(const ScalarList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScalarList& operator=(ScalarList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScalarList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScalarList* internal_default_instance() {
    return reinterpret_cast<const ScalarList*>(
               &_ScalarList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ScalarList& a, ScalarList& b) {
    a.Swap(&b);
  }
  inline void Swap(ScalarList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScalarList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScalarList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScalarList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScalarList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ScalarList& from) {
    ScalarList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ScalarList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.ScalarList";
  }
  protected:
  explicit ScalarList(::google::protobuf::Arena* arena);
  ScalarList(::google::protobuf::Arena* arena, const ScalarList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField<double>& values() const;
  ::google::protobuf::RepeatedField<double>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_values() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:codegen.ScalarList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class Memory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.Memory) */ {
 public:
  inline Memory() : Memory(nullptr) {}
  ~Memory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Memory(::google::protobuf::internal::ConstantInitialized);

  inline Memory(const Memory& from)
      : Memory(nullptr, from) {}
  Memory(Memory&& from) noexcept
    : Memory() {
    *this = ::std::move(from);
  }

  inline Memory& operator=(const Memory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Memory& operator=(Memory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Memory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Memory* internal_default_instance() {
    return reinterpret_cast<const Memory*>(
               &_Memory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Memory& a, Memory& b) {
    a.Swap(&b);
  }
  inline void Swap(Memory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Memory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Memory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Memory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Memory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Memory& from) {
    Memory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Memory* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.Memory";
  }
  protected:
  explicit Memory(::google::protobuf::Arena* arena);
  Memory(::google::protobuf::Arena* arena, const Memory& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 3,
    kPartitionFieldNumber = 2,
  };
  // uint64 address = 3;
  void clear_address() ;
  ::uint64_t address() const;
  void set_address(::uint64_t value);

  private:
  ::uint64_t _internal_address() const;
  void _internal_set_address(::uint64_t value);

  public:
  // int32 partition = 2;
  void clear_partition() ;
  ::int32_t partition() const;
  void set_partition(::int32_t value);

  private:
  ::int32_t _internal_partition() const;
  void _internal_set_partition(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:codegen.Memory)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t address_;
    ::int32_t partition_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class IntList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.IntList) */ {
 public:
  inline IntList() : IntList(nullptr) {}
  ~IntList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IntList(::google::protobuf::internal::ConstantInitialized);

  inline IntList(const IntList& from)
      : IntList(nullptr, from) {}
  IntList(IntList&& from) noexcept
    : IntList() {
    *this = ::std::move(from);
  }

  inline IntList& operator=(const IntList& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntList& operator=(IntList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntList& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntList* internal_default_instance() {
    return reinterpret_cast<const IntList*>(
               &_IntList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IntList& a, IntList& b) {
    a.Swap(&b);
  }
  inline void Swap(IntList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IntList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IntList& from) {
    IntList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IntList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.IntList";
  }
  protected:
  explicit IntList(::google::protobuf::Arena* arena);
  IntList(::google::protobuf::Arena* arena, const IntList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int64_t values(int index) const;
  void set_values(int index, ::int64_t value);
  void add_values(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& values() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:codegen.IntList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int64_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class BoolList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.BoolList) */ {
 public:
  inline BoolList() : BoolList(nullptr) {}
  ~BoolList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BoolList(::google::protobuf::internal::ConstantInitialized);

  inline BoolList(const BoolList& from)
      : BoolList(nullptr, from) {}
  BoolList(BoolList&& from) noexcept
    : BoolList() {
    *this = ::std::move(from);
  }

  inline BoolList& operator=(const BoolList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolList& operator=(BoolList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolList* internal_default_instance() {
    return reinterpret_cast<const BoolList*>(
               &_BoolList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BoolList& a, BoolList& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BoolList& from) {
    BoolList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoolList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.BoolList";
  }
  protected:
  explicit BoolList(::google::protobuf::Arena* arena);
  BoolList(::google::protobuf::Arena* arena, const BoolList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::google::protobuf::RepeatedField<bool>& values() const;
  ::google::protobuf::RepeatedField<bool>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_values() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:codegen.BoolList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<bool> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class Argument final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.Argument) */ {
 public:
  inline Argument() : Argument(nullptr) {}
  ~Argument() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Argument(::google::protobuf::internal::ConstantInitialized);

  inline Argument(const Argument& from)
      : Argument(nullptr, from) {}
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Argument& operator=(Argument&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Argument& default_instance() {
    return *internal_default_instance();
  }
  enum ArgTypeCase {
    kTensor = 1,
    kTensorList = 2,
    kIntList = 3,
    kIntValue = 4,
    kFloatValue = 5,
    kBoolValue = 6,
    kStrValue = 7,
    kBoolList = 8,
    kScalarList = 9,
    ARG_TYPE_NOT_SET = 0,
  };

  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }
  inline void Swap(Argument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Argument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Argument* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Argument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Argument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Argument& from) {
    Argument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Argument* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.Argument";
  }
  protected:
  explicit Argument(::google::protobuf::Arena* arena);
  Argument(::google::protobuf::Arena* arena, const Argument& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorFieldNumber = 1,
    kTensorListFieldNumber = 2,
    kIntListFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kFloatValueFieldNumber = 5,
    kBoolValueFieldNumber = 6,
    kStrValueFieldNumber = 7,
    kBoolListFieldNumber = 8,
    kScalarListFieldNumber = 9,
  };
  // .codegen.Tensor tensor = 1;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;

  public:
  void clear_tensor() ;
  const ::codegen::Tensor& tensor() const;
  PROTOBUF_NODISCARD ::codegen::Tensor* release_tensor();
  ::codegen::Tensor* mutable_tensor();
  void set_allocated_tensor(::codegen::Tensor* value);
  void unsafe_arena_set_allocated_tensor(::codegen::Tensor* value);
  ::codegen::Tensor* unsafe_arena_release_tensor();

  private:
  const ::codegen::Tensor& _internal_tensor() const;
  ::codegen::Tensor* _internal_mutable_tensor();

  public:
  // .codegen.TensorList tensor_list = 2;
  bool has_tensor_list() const;
  private:
  bool _internal_has_tensor_list() const;

  public:
  void clear_tensor_list() ;
  const ::codegen::TensorList& tensor_list() const;
  PROTOBUF_NODISCARD ::codegen::TensorList* release_tensor_list();
  ::codegen::TensorList* mutable_tensor_list();
  void set_allocated_tensor_list(::codegen::TensorList* value);
  void unsafe_arena_set_allocated_tensor_list(::codegen::TensorList* value);
  ::codegen::TensorList* unsafe_arena_release_tensor_list();

  private:
  const ::codegen::TensorList& _internal_tensor_list() const;
  ::codegen::TensorList* _internal_mutable_tensor_list();

  public:
  // .codegen.IntList int_list = 3;
  bool has_int_list() const;
  private:
  bool _internal_has_int_list() const;

  public:
  void clear_int_list() ;
  const ::codegen::IntList& int_list() const;
  PROTOBUF_NODISCARD ::codegen::IntList* release_int_list();
  ::codegen::IntList* mutable_int_list();
  void set_allocated_int_list(::codegen::IntList* value);
  void unsafe_arena_set_allocated_int_list(::codegen::IntList* value);
  ::codegen::IntList* unsafe_arena_release_int_list();

  private:
  const ::codegen::IntList& _internal_int_list() const;
  ::codegen::IntList* _internal_mutable_int_list();

  public:
  // int64 int_value = 4;
  bool has_int_value() const;
  void clear_int_value() ;
  ::int64_t int_value() const;
  void set_int_value(::int64_t value);

  private:
  ::int64_t _internal_int_value() const;
  void _internal_set_int_value(::int64_t value);

  public:
  // double float_value = 5;
  bool has_float_value() const;
  void clear_float_value() ;
  double float_value() const;
  void set_float_value(double value);

  private:
  double _internal_float_value() const;
  void _internal_set_float_value(double value);

  public:
  // bool bool_value = 6;
  bool has_bool_value() const;
  void clear_bool_value() ;
  bool bool_value() const;
  void set_bool_value(bool value);

  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);

  public:
  // string str_value = 7;
  bool has_str_value() const;
  void clear_str_value() ;
  const std::string& str_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_str_value(Arg_&& arg, Args_... args);
  std::string* mutable_str_value();
  PROTOBUF_NODISCARD std::string* release_str_value();
  void set_allocated_str_value(std::string* value);

  private:
  const std::string& _internal_str_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_value(
      const std::string& value);
  std::string* _internal_mutable_str_value();

  public:
  // .codegen.BoolList bool_list = 8;
  bool has_bool_list() const;
  private:
  bool _internal_has_bool_list() const;

  public:
  void clear_bool_list() ;
  const ::codegen::BoolList& bool_list() const;
  PROTOBUF_NODISCARD ::codegen::BoolList* release_bool_list();
  ::codegen::BoolList* mutable_bool_list();
  void set_allocated_bool_list(::codegen::BoolList* value);
  void unsafe_arena_set_allocated_bool_list(::codegen::BoolList* value);
  ::codegen::BoolList* unsafe_arena_release_bool_list();

  private:
  const ::codegen::BoolList& _internal_bool_list() const;
  ::codegen::BoolList* _internal_mutable_bool_list();

  public:
  // .codegen.ScalarList scalar_list = 9;
  bool has_scalar_list() const;
  private:
  bool _internal_has_scalar_list() const;

  public:
  void clear_scalar_list() ;
  const ::codegen::ScalarList& scalar_list() const;
  PROTOBUF_NODISCARD ::codegen::ScalarList* release_scalar_list();
  ::codegen::ScalarList* mutable_scalar_list();
  void set_allocated_scalar_list(::codegen::ScalarList* value);
  void unsafe_arena_set_allocated_scalar_list(::codegen::ScalarList* value);
  ::codegen::ScalarList* unsafe_arena_release_scalar_list();

  private:
  const ::codegen::ScalarList& _internal_scalar_list() const;
  ::codegen::ScalarList* _internal_mutable_scalar_list();

  public:
  void clear_arg_type();
  ArgTypeCase arg_type_case() const;
  // @@protoc_insertion_point(class_scope:codegen.Argument)
 private:
  class _Internal;
  void set_has_tensor();
  void set_has_tensor_list();
  void set_has_int_list();
  void set_has_int_value();
  void set_has_float_value();
  void set_has_bool_value();
  void set_has_str_value();
  void set_has_bool_list();
  void set_has_scalar_list();

  inline bool has_arg_type() const;
  inline void clear_has_arg_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 9, 5,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union ArgTypeUnion {
      constexpr ArgTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::codegen::Tensor* tensor_;
      ::codegen::TensorList* tensor_list_;
      ::codegen::IntList* int_list_;
      ::int64_t int_value_;
      double float_value_;
      bool bool_value_;
      ::google::protobuf::internal::ArenaStringPtr str_value_;
      ::codegen::BoolList* bool_list_;
      ::codegen::ScalarList* scalar_list_;
    } arg_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class OpOverload final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.OpOverload) */ {
 public:
  inline OpOverload() : OpOverload(nullptr) {}
  ~OpOverload() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OpOverload(::google::protobuf::internal::ConstantInitialized);

  inline OpOverload(const OpOverload& from)
      : OpOverload(nullptr, from) {}
  OpOverload(OpOverload&& from) noexcept
    : OpOverload() {
    *this = ::std::move(from);
  }

  inline OpOverload& operator=(const OpOverload& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpOverload& operator=(OpOverload&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpOverload& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpOverload* internal_default_instance() {
    return reinterpret_cast<const OpOverload*>(
               &_OpOverload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OpOverload& a, OpOverload& b) {
    a.Swap(&b);
  }
  inline void Swap(OpOverload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpOverload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpOverload* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpOverload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpOverload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OpOverload& from) {
    OpOverload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpOverload* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.OpOverload";
  }
  protected:
  explicit OpOverload(::google::protobuf::Arena* arena);
  OpOverload(::google::protobuf::Arena* arena, const OpOverload& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 4,
    kKwargsFieldNumber = 5,
    kNameFieldNumber = 1,
    kOpFieldNumber = 2,
    kTargetFieldNumber = 3,
  };
  // repeated .codegen.Argument args = 4;
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  ::codegen::Argument* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::codegen::Argument >*
      mutable_args();
  private:
  const ::google::protobuf::RepeatedPtrField<::codegen::Argument>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<::codegen::Argument>* _internal_mutable_args();
  public:
  const ::codegen::Argument& args(int index) const;
  ::codegen::Argument* add_args();
  const ::google::protobuf::RepeatedPtrField< ::codegen::Argument >&
      args() const;
  // map<string, .codegen.Argument> kwargs = 5;
  int kwargs_size() const;
  private:
  int _internal_kwargs_size() const;

  public:
  void clear_kwargs() ;
  const ::google::protobuf::Map<std::string, ::codegen::Argument>& kwargs() const;
  ::google::protobuf::Map<std::string, ::codegen::Argument>* mutable_kwargs();

  private:
  const ::google::protobuf::Map<std::string, ::codegen::Argument>& _internal_kwargs() const;
  ::google::protobuf::Map<std::string, ::codegen::Argument>* _internal_mutable_kwargs();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string op = 2;
  void clear_op() ;
  const std::string& op() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_op(Arg_&& arg, Args_... args);
  std::string* mutable_op();
  PROTOBUF_NODISCARD std::string* release_op();
  void set_allocated_op(std::string* value);

  private:
  const std::string& _internal_op() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op(
      const std::string& value);
  std::string* _internal_mutable_op();

  public:
  // string target = 3;
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:codegen.OpOverload)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 3,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::codegen::Argument > args_;
    ::google::protobuf::internal::MapField<OpOverload_KwargsEntry_DoNotUse, std::string, ::codegen::Argument,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        kwargs_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr op_;
    ::google::protobuf::internal::ArenaStringPtr target_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class OpOverload_KwargsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          OpOverload_KwargsEntry_DoNotUse, std::string, ::codegen::Argument,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      OpOverload_KwargsEntry_DoNotUse, std::string, ::codegen::Argument,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  OpOverload_KwargsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpOverload_KwargsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit OpOverload_KwargsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const OpOverload_KwargsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const OpOverload_KwargsEntry_DoNotUse*>(
        &_OpOverload_KwargsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "codegen.OpOverload.KwargsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_param_2eproto;
};
// -------------------------------------------------------------------

class Tensor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.Tensor) */ {
 public:
  inline Tensor() : Tensor(nullptr) {}
  ~Tensor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tensor(::google::protobuf::internal::ConstantInitialized);

  inline Tensor(const Tensor& from)
      : Tensor(nullptr, from) {}
  Tensor(Tensor&& from) noexcept
    : Tensor() {
    *this = ::std::move(from);
  }

  inline Tensor& operator=(const Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tensor& operator=(Tensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tensor* internal_default_instance() {
    return reinterpret_cast<const Tensor*>(
               &_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Tensor& a, Tensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Tensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tensor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Tensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Tensor& from) {
    Tensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Tensor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.Tensor";
  }
  protected:
  explicit Tensor(::google::protobuf::Arena* arena);
  Tensor(::google::protobuf::Arena* arena, const Tensor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 2,
    kNodeFieldNumber = 1,
    kDtypeFieldNumber = 3,
    kMemoryFieldNumber = 4,
    kScratchpadFieldNumber = 5,
    kReshapeFieldNumber = 7,
    kScaleFieldNumber = 6,
    kIsNoneFieldNumber = 8,
  };
  // repeated int32 shape = 2;
  int shape_size() const;
  private:
  int _internal_shape_size() const;

  public:
  void clear_shape() ;
  ::int32_t shape(int index) const;
  void set_shape(int index, ::int32_t value);
  void add_shape(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& shape() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_shape();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_shape() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_shape();

  public:
  // string node = 1;
  void clear_node() ;
  const std::string& node() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node(Arg_&& arg, Args_... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* value);

  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(
      const std::string& value);
  std::string* _internal_mutable_node();

  public:
  // string dtype = 3;
  void clear_dtype() ;
  const std::string& dtype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dtype(Arg_&& arg, Args_... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* value);

  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(
      const std::string& value);
  std::string* _internal_mutable_dtype();

  public:
  // optional .codegen.Memory memory = 4;
  bool has_memory() const;
  void clear_memory() ;
  const ::codegen::Memory& memory() const;
  PROTOBUF_NODISCARD ::codegen::Memory* release_memory();
  ::codegen::Memory* mutable_memory();
  void set_allocated_memory(::codegen::Memory* value);
  void unsafe_arena_set_allocated_memory(::codegen::Memory* value);
  ::codegen::Memory* unsafe_arena_release_memory();

  private:
  const ::codegen::Memory& _internal_memory() const;
  ::codegen::Memory* _internal_mutable_memory();

  public:
  // optional .codegen.ScratchpadInfo scratchpad = 5;
  bool has_scratchpad() const;
  void clear_scratchpad() ;
  const ::codegen::ScratchpadInfo& scratchpad() const;
  PROTOBUF_NODISCARD ::codegen::ScratchpadInfo* release_scratchpad();
  ::codegen::ScratchpadInfo* mutable_scratchpad();
  void set_allocated_scratchpad(::codegen::ScratchpadInfo* value);
  void unsafe_arena_set_allocated_scratchpad(::codegen::ScratchpadInfo* value);
  ::codegen::ScratchpadInfo* unsafe_arena_release_scratchpad();

  private:
  const ::codegen::ScratchpadInfo& _internal_scratchpad() const;
  ::codegen::ScratchpadInfo* _internal_mutable_scratchpad();

  public:
  // optional .codegen.OpOverload reshape = 7;
  bool has_reshape() const;
  void clear_reshape() ;
  const ::codegen::OpOverload& reshape() const;
  PROTOBUF_NODISCARD ::codegen::OpOverload* release_reshape();
  ::codegen::OpOverload* mutable_reshape();
  void set_allocated_reshape(::codegen::OpOverload* value);
  void unsafe_arena_set_allocated_reshape(::codegen::OpOverload* value);
  ::codegen::OpOverload* unsafe_arena_release_reshape();

  private:
  const ::codegen::OpOverload& _internal_reshape() const;
  ::codegen::OpOverload* _internal_mutable_reshape();

  public:
  // optional double scale = 6;
  bool has_scale() const;
  void clear_scale() ;
  double scale() const;
  void set_scale(double value);

  private:
  double _internal_scale() const;
  void _internal_set_scale(double value);

  public:
  // bool is_none = 8;
  void clear_is_none() ;
  bool is_none() const;
  void set_is_none(bool value);

  private:
  bool _internal_is_none() const;
  void _internal_set_is_none(bool value);

  public:
  // @@protoc_insertion_point(class_scope:codegen.Tensor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> shape_;
    mutable ::google::protobuf::internal::CachedSize _shape_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr node_;
    ::google::protobuf::internal::ArenaStringPtr dtype_;
    ::codegen::Memory* memory_;
    ::codegen::ScratchpadInfo* scratchpad_;
    ::codegen::OpOverload* reshape_;
    double scale_;
    bool is_none_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class TensorList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.TensorList) */ {
 public:
  inline TensorList() : TensorList(nullptr) {}
  ~TensorList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TensorList(::google::protobuf::internal::ConstantInitialized);

  inline TensorList(const TensorList& from)
      : TensorList(nullptr, from) {}
  TensorList(TensorList&& from) noexcept
    : TensorList() {
    *this = ::std::move(from);
  }

  inline TensorList& operator=(const TensorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorList& operator=(TensorList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorList* internal_default_instance() {
    return reinterpret_cast<const TensorList*>(
               &_TensorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TensorList& a, TensorList& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TensorList& from) {
    TensorList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.TensorList";
  }
  protected:
  explicit TensorList(::google::protobuf::Arena* arena);
  TensorList(::google::protobuf::Arena* arena, const TensorList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorsFieldNumber = 1,
  };
  // repeated .codegen.Tensor tensors = 1;
  int tensors_size() const;
  private:
  int _internal_tensors_size() const;

  public:
  void clear_tensors() ;
  ::codegen::Tensor* mutable_tensors(int index);
  ::google::protobuf::RepeatedPtrField< ::codegen::Tensor >*
      mutable_tensors();
  private:
  const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>& _internal_tensors() const;
  ::google::protobuf::RepeatedPtrField<::codegen::Tensor>* _internal_mutable_tensors();
  public:
  const ::codegen::Tensor& tensors(int index) const;
  ::codegen::Tensor* add_tensors();
  const ::google::protobuf::RepeatedPtrField< ::codegen::Tensor >&
      tensors() const;
  // @@protoc_insertion_point(class_scope:codegen.TensorList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::codegen::Tensor > tensors_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class OpOverloadList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.OpOverloadList) */ {
 public:
  inline OpOverloadList() : OpOverloadList(nullptr) {}
  ~OpOverloadList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OpOverloadList(::google::protobuf::internal::ConstantInitialized);

  inline OpOverloadList(const OpOverloadList& from)
      : OpOverloadList(nullptr, from) {}
  OpOverloadList(OpOverloadList&& from) noexcept
    : OpOverloadList() {
    *this = ::std::move(from);
  }

  inline OpOverloadList& operator=(const OpOverloadList& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpOverloadList& operator=(OpOverloadList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpOverloadList& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpOverloadList* internal_default_instance() {
    return reinterpret_cast<const OpOverloadList*>(
               &_OpOverloadList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OpOverloadList& a, OpOverloadList& b) {
    a.Swap(&b);
  }
  inline void Swap(OpOverloadList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpOverloadList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpOverloadList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpOverloadList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpOverloadList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OpOverloadList& from) {
    OpOverloadList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpOverloadList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.OpOverloadList";
  }
  protected:
  explicit OpOverloadList(::google::protobuf::Arena* arena);
  OpOverloadList(::google::protobuf::Arena* arena, const OpOverloadList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpListFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .codegen.OpOverload op_list = 2;
  int op_list_size() const;
  private:
  int _internal_op_list_size() const;

  public:
  void clear_op_list() ;
  ::codegen::OpOverload* mutable_op_list(int index);
  ::google::protobuf::RepeatedPtrField< ::codegen::OpOverload >*
      mutable_op_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::codegen::OpOverload>& _internal_op_list() const;
  ::google::protobuf::RepeatedPtrField<::codegen::OpOverload>* _internal_mutable_op_list();
  public:
  const ::codegen::OpOverload& op_list(int index) const;
  ::codegen::OpOverload* add_op_list();
  const ::google::protobuf::RepeatedPtrField< ::codegen::OpOverload >&
      op_list() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:codegen.OpOverloadList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::codegen::OpOverload > op_list_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class Operation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Operation(::google::protobuf::internal::ConstantInitialized);

  inline Operation(const Operation& from)
      : Operation(nullptr, from) {}
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  enum OpTypeCase {
    kOp = 2,
    kFusedOp = 3,
    OP_TYPE_NOT_SET = 0,
  };

  enum ReturnTypeCase {
    kOutput = 4,
    kOutputs = 5,
    RETURN_TYPE_NOT_SET = 0,
  };

  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Operation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.Operation";
  }
  protected:
  explicit Operation(::google::protobuf::Arena* arena);
  Operation(::google::protobuf::Arena* arena, const Operation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 2,
    kFusedOpFieldNumber = 3,
    kOutputFieldNumber = 4,
    kOutputsFieldNumber = 5,
  };
  // .codegen.OpOverload op = 2;
  bool has_op() const;
  private:
  bool _internal_has_op() const;

  public:
  void clear_op() ;
  const ::codegen::OpOverload& op() const;
  PROTOBUF_NODISCARD ::codegen::OpOverload* release_op();
  ::codegen::OpOverload* mutable_op();
  void set_allocated_op(::codegen::OpOverload* value);
  void unsafe_arena_set_allocated_op(::codegen::OpOverload* value);
  ::codegen::OpOverload* unsafe_arena_release_op();

  private:
  const ::codegen::OpOverload& _internal_op() const;
  ::codegen::OpOverload* _internal_mutable_op();

  public:
  // .codegen.OpOverloadList fused_op = 3;
  bool has_fused_op() const;
  private:
  bool _internal_has_fused_op() const;

  public:
  void clear_fused_op() ;
  const ::codegen::OpOverloadList& fused_op() const;
  PROTOBUF_NODISCARD ::codegen::OpOverloadList* release_fused_op();
  ::codegen::OpOverloadList* mutable_fused_op();
  void set_allocated_fused_op(::codegen::OpOverloadList* value);
  void unsafe_arena_set_allocated_fused_op(::codegen::OpOverloadList* value);
  ::codegen::OpOverloadList* unsafe_arena_release_fused_op();

  private:
  const ::codegen::OpOverloadList& _internal_fused_op() const;
  ::codegen::OpOverloadList* _internal_mutable_fused_op();

  public:
  // .codegen.Tensor output = 4;
  bool has_output() const;
  private:
  bool _internal_has_output() const;

  public:
  void clear_output() ;
  const ::codegen::Tensor& output() const;
  PROTOBUF_NODISCARD ::codegen::Tensor* release_output();
  ::codegen::Tensor* mutable_output();
  void set_allocated_output(::codegen::Tensor* value);
  void unsafe_arena_set_allocated_output(::codegen::Tensor* value);
  ::codegen::Tensor* unsafe_arena_release_output();

  private:
  const ::codegen::Tensor& _internal_output() const;
  ::codegen::Tensor* _internal_mutable_output();

  public:
  // .codegen.TensorList outputs = 5;
  bool has_outputs() const;
  private:
  bool _internal_has_outputs() const;

  public:
  void clear_outputs() ;
  const ::codegen::TensorList& outputs() const;
  PROTOBUF_NODISCARD ::codegen::TensorList* release_outputs();
  ::codegen::TensorList* mutable_outputs();
  void set_allocated_outputs(::codegen::TensorList* value);
  void unsafe_arena_set_allocated_outputs(::codegen::TensorList* value);
  ::codegen::TensorList* unsafe_arena_release_outputs();

  private:
  const ::codegen::TensorList& _internal_outputs() const;
  ::codegen::TensorList* _internal_mutable_outputs();

  public:
  void clear_op_type();
  OpTypeCase op_type_case() const;
  void clear_return_type();
  ReturnTypeCase return_type_case() const;
  // @@protoc_insertion_point(class_scope:codegen.Operation)
 private:
  class _Internal;
  void set_has_op();
  void set_has_fused_op();
  void set_has_output();
  void set_has_outputs();

  inline bool has_op_type() const;
  inline void clear_has_op_type();

  inline bool has_return_type() const;
  inline void clear_has_return_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union OpTypeUnion {
      constexpr OpTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::codegen::OpOverload* op_;
      ::codegen::OpOverloadList* fused_op_;
    } op_type_;
    union ReturnTypeUnion {
      constexpr ReturnTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::codegen::Tensor* output_;
      ::codegen::TensorList* outputs_;
    } return_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};// -------------------------------------------------------------------

class Model final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:codegen.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Model(::google::protobuf::internal::ConstantInitialized);

  inline Model(const Model& from)
      : Model(nullptr, from) {}
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Model* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "codegen.Model";
  }
  protected:
  explicit Model(::google::protobuf::Arena* arena);
  Model(::google::protobuf::Arena* arena, const Model& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 1,
    kParametersFieldNumber = 2,
    kOpsFieldNumber = 3,
  };
  // repeated .codegen.Tensor inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::codegen::Tensor* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::codegen::Tensor >*
      mutable_inputs();
  private:
  const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::codegen::Tensor>* _internal_mutable_inputs();
  public:
  const ::codegen::Tensor& inputs(int index) const;
  ::codegen::Tensor* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::codegen::Tensor >&
      inputs() const;
  // repeated .codegen.Tensor parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  ::codegen::Tensor* mutable_parameters(int index);
  ::google::protobuf::RepeatedPtrField< ::codegen::Tensor >*
      mutable_parameters();
  private:
  const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>& _internal_parameters() const;
  ::google::protobuf::RepeatedPtrField<::codegen::Tensor>* _internal_mutable_parameters();
  public:
  const ::codegen::Tensor& parameters(int index) const;
  ::codegen::Tensor* add_parameters();
  const ::google::protobuf::RepeatedPtrField< ::codegen::Tensor >&
      parameters() const;
  // repeated .codegen.Operation ops = 3;
  int ops_size() const;
  private:
  int _internal_ops_size() const;

  public:
  void clear_ops() ;
  ::codegen::Operation* mutable_ops(int index);
  ::google::protobuf::RepeatedPtrField< ::codegen::Operation >*
      mutable_ops();
  private:
  const ::google::protobuf::RepeatedPtrField<::codegen::Operation>& _internal_ops() const;
  ::google::protobuf::RepeatedPtrField<::codegen::Operation>* _internal_mutable_ops();
  public:
  const ::codegen::Operation& ops(int index) const;
  ::codegen::Operation* add_ops();
  const ::google::protobuf::RepeatedPtrField< ::codegen::Operation >&
      ops() const;
  // @@protoc_insertion_point(class_scope:codegen.Model)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::codegen::Tensor > inputs_;
    ::google::protobuf::RepeatedPtrField< ::codegen::Tensor > parameters_;
    ::google::protobuf::RepeatedPtrField< ::codegen::Operation > ops_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_param_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Memory

// int32 partition = 2;
inline void Memory::clear_partition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partition_ = 0;
}
inline ::int32_t Memory::partition() const {
  // @@protoc_insertion_point(field_get:codegen.Memory.partition)
  return _internal_partition();
}
inline void Memory::set_partition(::int32_t value) {
  _internal_set_partition(value);
  // @@protoc_insertion_point(field_set:codegen.Memory.partition)
}
inline ::int32_t Memory::_internal_partition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partition_;
}
inline void Memory::_internal_set_partition(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.partition_ = value;
}

// uint64 address = 3;
inline void Memory::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_ = ::uint64_t{0u};
}
inline ::uint64_t Memory::address() const {
  // @@protoc_insertion_point(field_get:codegen.Memory.address)
  return _internal_address();
}
inline void Memory::set_address(::uint64_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:codegen.Memory.address)
}
inline ::uint64_t Memory::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_;
}
inline void Memory::_internal_set_address(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_ = value;
}

// -------------------------------------------------------------------

// ScratchpadInfo

// int32 bank = 1;
inline void ScratchpadInfo::clear_bank() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bank_ = 0;
}
inline ::int32_t ScratchpadInfo::bank() const {
  // @@protoc_insertion_point(field_get:codegen.ScratchpadInfo.bank)
  return _internal_bank();
}
inline void ScratchpadInfo::set_bank(::int32_t value) {
  _internal_set_bank(value);
  // @@protoc_insertion_point(field_set:codegen.ScratchpadInfo.bank)
}
inline ::int32_t ScratchpadInfo::_internal_bank() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bank_;
}
inline void ScratchpadInfo::_internal_set_bank(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bank_ = value;
}

// uint64 offset = 2;
inline void ScratchpadInfo::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = ::uint64_t{0u};
}
inline ::uint64_t ScratchpadInfo::offset() const {
  // @@protoc_insertion_point(field_get:codegen.ScratchpadInfo.offset)
  return _internal_offset();
}
inline void ScratchpadInfo::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:codegen.ScratchpadInfo.offset)
}
inline ::uint64_t ScratchpadInfo::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void ScratchpadInfo::_internal_set_offset(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// Tensor

// string node = 1;
inline void Tensor::clear_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_.ClearToEmpty();
}
inline const std::string& Tensor::node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Tensor.node)
  return _internal_node();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tensor::set_node(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:codegen.Tensor.node)
}
inline std::string* Tensor::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:codegen.Tensor.node)
  return _s;
}
inline const std::string& Tensor::_internal_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_.Get();
}
inline void Tensor::_internal_set_node(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_.Set(value, GetArena());
}
inline std::string* Tensor::_internal_mutable_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_.Mutable( GetArena());
}
inline std::string* Tensor::release_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.Tensor.node)
  return _impl_.node_.Release();
}
inline void Tensor::set_allocated_node(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_.IsDefault()) {
          _impl_.node_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:codegen.Tensor.node)
}

// repeated int32 shape = 2;
inline int Tensor::_internal_shape_size() const {
  return _internal_shape().size();
}
inline int Tensor::shape_size() const {
  return _internal_shape_size();
}
inline void Tensor::clear_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shape_.Clear();
}
inline ::int32_t Tensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:codegen.Tensor.shape)
  return _internal_shape().Get(index);
}
inline void Tensor::set_shape(int index, ::int32_t value) {
  _internal_mutable_shape()->Set(index, value);
  // @@protoc_insertion_point(field_set:codegen.Tensor.shape)
}
inline void Tensor::add_shape(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_shape()->Add(value);
  // @@protoc_insertion_point(field_add:codegen.Tensor.shape)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Tensor::shape() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.Tensor.shape)
  return _internal_shape();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Tensor::mutable_shape()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.Tensor.shape)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_shape();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Tensor::_internal_shape()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shape_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Tensor::_internal_mutable_shape() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.shape_;
}

// string dtype = 3;
inline void Tensor::clear_dtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dtype_.ClearToEmpty();
}
inline const std::string& Tensor::dtype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Tensor.dtype)
  return _internal_dtype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tensor::set_dtype(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dtype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:codegen.Tensor.dtype)
}
inline std::string* Tensor::mutable_dtype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:codegen.Tensor.dtype)
  return _s;
}
inline const std::string& Tensor::_internal_dtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dtype_.Get();
}
inline void Tensor::_internal_set_dtype(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dtype_.Set(value, GetArena());
}
inline std::string* Tensor::_internal_mutable_dtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dtype_.Mutable( GetArena());
}
inline std::string* Tensor::release_dtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.Tensor.dtype)
  return _impl_.dtype_.Release();
}
inline void Tensor::set_allocated_dtype(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dtype_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dtype_.IsDefault()) {
          _impl_.dtype_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:codegen.Tensor.dtype)
}

// optional .codegen.Memory memory = 4;
inline bool Tensor::has_memory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.memory_ != nullptr);
  return value;
}
inline void Tensor::clear_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.memory_ != nullptr) _impl_.memory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::codegen::Memory& Tensor::_internal_memory() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::codegen::Memory* p = _impl_.memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::codegen::Memory&>(::codegen::_Memory_default_instance_);
}
inline const ::codegen::Memory& Tensor::memory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Tensor.memory)
  return _internal_memory();
}
inline void Tensor::unsafe_arena_set_allocated_memory(::codegen::Memory* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_);
  }
  _impl_.memory_ = reinterpret_cast<::codegen::Memory*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Tensor.memory)
}
inline ::codegen::Memory* Tensor::release_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::codegen::Memory* released = _impl_.memory_;
  _impl_.memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::codegen::Memory* Tensor::unsafe_arena_release_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.Tensor.memory)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::codegen::Memory* temp = _impl_.memory_;
  _impl_.memory_ = nullptr;
  return temp;
}
inline ::codegen::Memory* Tensor::_internal_mutable_memory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::codegen::Memory>(GetArena());
    _impl_.memory_ = reinterpret_cast<::codegen::Memory*>(p);
  }
  return _impl_.memory_;
}
inline ::codegen::Memory* Tensor::mutable_memory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::Memory* _msg = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:codegen.Tensor.memory)
  return _msg;
}
inline void Tensor::set_allocated_memory(::codegen::Memory* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::codegen::Memory*>(_impl_.memory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::codegen::Memory*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.memory_ = reinterpret_cast<::codegen::Memory*>(value);
  // @@protoc_insertion_point(field_set_allocated:codegen.Tensor.memory)
}

// optional .codegen.ScratchpadInfo scratchpad = 5;
inline bool Tensor::has_scratchpad() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scratchpad_ != nullptr);
  return value;
}
inline void Tensor::clear_scratchpad() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.scratchpad_ != nullptr) _impl_.scratchpad_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::codegen::ScratchpadInfo& Tensor::_internal_scratchpad() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::codegen::ScratchpadInfo* p = _impl_.scratchpad_;
  return p != nullptr ? *p : reinterpret_cast<const ::codegen::ScratchpadInfo&>(::codegen::_ScratchpadInfo_default_instance_);
}
inline const ::codegen::ScratchpadInfo& Tensor::scratchpad() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Tensor.scratchpad)
  return _internal_scratchpad();
}
inline void Tensor::unsafe_arena_set_allocated_scratchpad(::codegen::ScratchpadInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scratchpad_);
  }
  _impl_.scratchpad_ = reinterpret_cast<::codegen::ScratchpadInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Tensor.scratchpad)
}
inline ::codegen::ScratchpadInfo* Tensor::release_scratchpad() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::codegen::ScratchpadInfo* released = _impl_.scratchpad_;
  _impl_.scratchpad_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::codegen::ScratchpadInfo* Tensor::unsafe_arena_release_scratchpad() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.Tensor.scratchpad)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::codegen::ScratchpadInfo* temp = _impl_.scratchpad_;
  _impl_.scratchpad_ = nullptr;
  return temp;
}
inline ::codegen::ScratchpadInfo* Tensor::_internal_mutable_scratchpad() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.scratchpad_ == nullptr) {
    auto* p = CreateMaybeMessage<::codegen::ScratchpadInfo>(GetArena());
    _impl_.scratchpad_ = reinterpret_cast<::codegen::ScratchpadInfo*>(p);
  }
  return _impl_.scratchpad_;
}
inline ::codegen::ScratchpadInfo* Tensor::mutable_scratchpad() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::ScratchpadInfo* _msg = _internal_mutable_scratchpad();
  // @@protoc_insertion_point(field_mutable:codegen.Tensor.scratchpad)
  return _msg;
}
inline void Tensor::set_allocated_scratchpad(::codegen::ScratchpadInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::codegen::ScratchpadInfo*>(_impl_.scratchpad_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::codegen::ScratchpadInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.scratchpad_ = reinterpret_cast<::codegen::ScratchpadInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:codegen.Tensor.scratchpad)
}

// optional double scale = 6;
inline bool Tensor::has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Tensor::clear_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Tensor::scale() const {
  // @@protoc_insertion_point(field_get:codegen.Tensor.scale)
  return _internal_scale();
}
inline void Tensor::set_scale(double value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:codegen.Tensor.scale)
}
inline double Tensor::_internal_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scale_;
}
inline void Tensor::_internal_set_scale(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.scale_ = value;
}

// optional .codegen.OpOverload reshape = 7;
inline bool Tensor::has_reshape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reshape_ != nullptr);
  return value;
}
inline void Tensor::clear_reshape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reshape_ != nullptr) _impl_.reshape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::codegen::OpOverload& Tensor::_internal_reshape() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::codegen::OpOverload* p = _impl_.reshape_;
  return p != nullptr ? *p : reinterpret_cast<const ::codegen::OpOverload&>(::codegen::_OpOverload_default_instance_);
}
inline const ::codegen::OpOverload& Tensor::reshape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Tensor.reshape)
  return _internal_reshape();
}
inline void Tensor::unsafe_arena_set_allocated_reshape(::codegen::OpOverload* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reshape_);
  }
  _impl_.reshape_ = reinterpret_cast<::codegen::OpOverload*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Tensor.reshape)
}
inline ::codegen::OpOverload* Tensor::release_reshape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::codegen::OpOverload* released = _impl_.reshape_;
  _impl_.reshape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::codegen::OpOverload* Tensor::unsafe_arena_release_reshape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.Tensor.reshape)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::codegen::OpOverload* temp = _impl_.reshape_;
  _impl_.reshape_ = nullptr;
  return temp;
}
inline ::codegen::OpOverload* Tensor::_internal_mutable_reshape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.reshape_ == nullptr) {
    auto* p = CreateMaybeMessage<::codegen::OpOverload>(GetArena());
    _impl_.reshape_ = reinterpret_cast<::codegen::OpOverload*>(p);
  }
  return _impl_.reshape_;
}
inline ::codegen::OpOverload* Tensor::mutable_reshape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::OpOverload* _msg = _internal_mutable_reshape();
  // @@protoc_insertion_point(field_mutable:codegen.Tensor.reshape)
  return _msg;
}
inline void Tensor::set_allocated_reshape(::codegen::OpOverload* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::codegen::OpOverload*>(_impl_.reshape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::codegen::OpOverload*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.reshape_ = reinterpret_cast<::codegen::OpOverload*>(value);
  // @@protoc_insertion_point(field_set_allocated:codegen.Tensor.reshape)
}

// bool is_none = 8;
inline void Tensor::clear_is_none() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_none_ = false;
}
inline bool Tensor::is_none() const {
  // @@protoc_insertion_point(field_get:codegen.Tensor.is_none)
  return _internal_is_none();
}
inline void Tensor::set_is_none(bool value) {
  _internal_set_is_none(value);
  // @@protoc_insertion_point(field_set:codegen.Tensor.is_none)
}
inline bool Tensor::_internal_is_none() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_none_;
}
inline void Tensor::_internal_set_is_none(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_none_ = value;
}

// -------------------------------------------------------------------

// TensorList

// repeated .codegen.Tensor tensors = 1;
inline int TensorList::_internal_tensors_size() const {
  return _internal_tensors().size();
}
inline int TensorList::tensors_size() const {
  return _internal_tensors_size();
}
inline void TensorList::clear_tensors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tensors_.Clear();
}
inline ::codegen::Tensor* TensorList::mutable_tensors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:codegen.TensorList.tensors)
  return _internal_mutable_tensors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Tensor>* TensorList::mutable_tensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.TensorList.tensors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tensors();
}
inline const ::codegen::Tensor& TensorList::tensors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.TensorList.tensors)
  return _internal_tensors().Get(index);
}
inline ::codegen::Tensor* TensorList::add_tensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::codegen::Tensor* _add = _internal_mutable_tensors()->Add();
  // @@protoc_insertion_point(field_add:codegen.TensorList.tensors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>& TensorList::tensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.TensorList.tensors)
  return _internal_tensors();
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>&
TensorList::_internal_tensors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tensors_;
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Tensor>*
TensorList::_internal_mutable_tensors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tensors_;
}

// -------------------------------------------------------------------

// IntList

// repeated int64 values = 1;
inline int IntList::_internal_values_size() const {
  return _internal_values().size();
}
inline int IntList::values_size() const {
  return _internal_values_size();
}
inline void IntList::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int64_t IntList::values(int index) const {
  // @@protoc_insertion_point(field_get:codegen.IntList.values)
  return _internal_values().Get(index);
}
inline void IntList::set_values(int index, ::int64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:codegen.IntList.values)
}
inline void IntList::add_values(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:codegen.IntList.values)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& IntList::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.IntList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int64_t>* IntList::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.IntList.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& IntList::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* IntList::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BoolList

// repeated bool values = 1;
inline int BoolList::_internal_values_size() const {
  return _internal_values().size();
}
inline int BoolList::values_size() const {
  return _internal_values_size();
}
inline void BoolList::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline bool BoolList::values(int index) const {
  // @@protoc_insertion_point(field_get:codegen.BoolList.values)
  return _internal_values().Get(index);
}
inline void BoolList::set_values(int index, bool value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:codegen.BoolList.values)
}
inline void BoolList::add_values(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:codegen.BoolList.values)
}
inline const ::google::protobuf::RepeatedField<bool>& BoolList::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.BoolList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<bool>* BoolList::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.BoolList.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<bool>& BoolList::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<bool>* BoolList::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// ScalarList

// repeated double values = 1;
inline int ScalarList::_internal_values_size() const {
  return _internal_values().size();
}
inline int ScalarList::values_size() const {
  return _internal_values_size();
}
inline void ScalarList::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline double ScalarList::values(int index) const {
  // @@protoc_insertion_point(field_get:codegen.ScalarList.values)
  return _internal_values().Get(index);
}
inline void ScalarList::set_values(int index, double value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:codegen.ScalarList.values)
}
inline void ScalarList::add_values(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:codegen.ScalarList.values)
}
inline const ::google::protobuf::RepeatedField<double>& ScalarList::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.ScalarList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<double>* ScalarList::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.ScalarList.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<double>& ScalarList::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<double>* ScalarList::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Argument

// .codegen.Tensor tensor = 1;
inline bool Argument::has_tensor() const {
  return arg_type_case() == kTensor;
}
inline bool Argument::_internal_has_tensor() const {
  return arg_type_case() == kTensor;
}
inline void Argument::set_has_tensor() {
  _impl_._oneof_case_[0] = kTensor;
}
inline void Argument::clear_tensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kTensor) {
    if (GetArena() == nullptr) {
      delete _impl_.arg_type_.tensor_;
    }
    clear_has_arg_type();
  }
}
inline ::codegen::Tensor* Argument::release_tensor() {
  // @@protoc_insertion_point(field_release:codegen.Argument.tensor)
  if (arg_type_case() == kTensor) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.tensor_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_type_.tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::Tensor& Argument::_internal_tensor() const {
  return arg_type_case() == kTensor ? *_impl_.arg_type_.tensor_ : reinterpret_cast<::codegen::Tensor&>(::codegen::_Tensor_default_instance_);
}
inline const ::codegen::Tensor& Argument::tensor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Argument.tensor)
  return _internal_tensor();
}
inline ::codegen::Tensor* Argument::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Argument.tensor)
  if (arg_type_case() == kTensor) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.tensor_;
    _impl_.arg_type_.tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Argument::unsafe_arena_set_allocated_tensor(::codegen::Tensor* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_arg_type();
  if (value) {
    set_has_tensor();
    _impl_.arg_type_.tensor_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Argument.tensor)
}
inline ::codegen::Tensor* Argument::_internal_mutable_tensor() {
  if (arg_type_case() != kTensor) {
    clear_arg_type();
    set_has_tensor();
    _impl_.arg_type_.tensor_ = CreateMaybeMessage<::codegen::Tensor>(GetArena());
  }
  return _impl_.arg_type_.tensor_;
}
inline ::codegen::Tensor* Argument::mutable_tensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::Tensor* _msg = _internal_mutable_tensor();
  // @@protoc_insertion_point(field_mutable:codegen.Argument.tensor)
  return _msg;
}

// .codegen.TensorList tensor_list = 2;
inline bool Argument::has_tensor_list() const {
  return arg_type_case() == kTensorList;
}
inline bool Argument::_internal_has_tensor_list() const {
  return arg_type_case() == kTensorList;
}
inline void Argument::set_has_tensor_list() {
  _impl_._oneof_case_[0] = kTensorList;
}
inline void Argument::clear_tensor_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kTensorList) {
    if (GetArena() == nullptr) {
      delete _impl_.arg_type_.tensor_list_;
    }
    clear_has_arg_type();
  }
}
inline ::codegen::TensorList* Argument::release_tensor_list() {
  // @@protoc_insertion_point(field_release:codegen.Argument.tensor_list)
  if (arg_type_case() == kTensorList) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.tensor_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_type_.tensor_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::TensorList& Argument::_internal_tensor_list() const {
  return arg_type_case() == kTensorList ? *_impl_.arg_type_.tensor_list_ : reinterpret_cast<::codegen::TensorList&>(::codegen::_TensorList_default_instance_);
}
inline const ::codegen::TensorList& Argument::tensor_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Argument.tensor_list)
  return _internal_tensor_list();
}
inline ::codegen::TensorList* Argument::unsafe_arena_release_tensor_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Argument.tensor_list)
  if (arg_type_case() == kTensorList) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.tensor_list_;
    _impl_.arg_type_.tensor_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Argument::unsafe_arena_set_allocated_tensor_list(::codegen::TensorList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_arg_type();
  if (value) {
    set_has_tensor_list();
    _impl_.arg_type_.tensor_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Argument.tensor_list)
}
inline ::codegen::TensorList* Argument::_internal_mutable_tensor_list() {
  if (arg_type_case() != kTensorList) {
    clear_arg_type();
    set_has_tensor_list();
    _impl_.arg_type_.tensor_list_ = CreateMaybeMessage<::codegen::TensorList>(GetArena());
  }
  return _impl_.arg_type_.tensor_list_;
}
inline ::codegen::TensorList* Argument::mutable_tensor_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::TensorList* _msg = _internal_mutable_tensor_list();
  // @@protoc_insertion_point(field_mutable:codegen.Argument.tensor_list)
  return _msg;
}

// .codegen.IntList int_list = 3;
inline bool Argument::has_int_list() const {
  return arg_type_case() == kIntList;
}
inline bool Argument::_internal_has_int_list() const {
  return arg_type_case() == kIntList;
}
inline void Argument::set_has_int_list() {
  _impl_._oneof_case_[0] = kIntList;
}
inline void Argument::clear_int_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kIntList) {
    if (GetArena() == nullptr) {
      delete _impl_.arg_type_.int_list_;
    }
    clear_has_arg_type();
  }
}
inline ::codegen::IntList* Argument::release_int_list() {
  // @@protoc_insertion_point(field_release:codegen.Argument.int_list)
  if (arg_type_case() == kIntList) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.int_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_type_.int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::IntList& Argument::_internal_int_list() const {
  return arg_type_case() == kIntList ? *_impl_.arg_type_.int_list_ : reinterpret_cast<::codegen::IntList&>(::codegen::_IntList_default_instance_);
}
inline const ::codegen::IntList& Argument::int_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Argument.int_list)
  return _internal_int_list();
}
inline ::codegen::IntList* Argument::unsafe_arena_release_int_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Argument.int_list)
  if (arg_type_case() == kIntList) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.int_list_;
    _impl_.arg_type_.int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Argument::unsafe_arena_set_allocated_int_list(::codegen::IntList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_arg_type();
  if (value) {
    set_has_int_list();
    _impl_.arg_type_.int_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Argument.int_list)
}
inline ::codegen::IntList* Argument::_internal_mutable_int_list() {
  if (arg_type_case() != kIntList) {
    clear_arg_type();
    set_has_int_list();
    _impl_.arg_type_.int_list_ = CreateMaybeMessage<::codegen::IntList>(GetArena());
  }
  return _impl_.arg_type_.int_list_;
}
inline ::codegen::IntList* Argument::mutable_int_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::IntList* _msg = _internal_mutable_int_list();
  // @@protoc_insertion_point(field_mutable:codegen.Argument.int_list)
  return _msg;
}

// int64 int_value = 4;
inline bool Argument::has_int_value() const {
  return arg_type_case() == kIntValue;
}
inline void Argument::set_has_int_value() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void Argument::clear_int_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kIntValue) {
    _impl_.arg_type_.int_value_ = ::int64_t{0};
    clear_has_arg_type();
  }
}
inline ::int64_t Argument::int_value() const {
  // @@protoc_insertion_point(field_get:codegen.Argument.int_value)
  return _internal_int_value();
}
inline void Argument::set_int_value(::int64_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:codegen.Argument.int_value)
}
inline ::int64_t Argument::_internal_int_value() const {
  if (arg_type_case() == kIntValue) {
    return _impl_.arg_type_.int_value_;
  }
  return ::int64_t{0};
}
inline void Argument::_internal_set_int_value(::int64_t value) {
  if (arg_type_case() != kIntValue) {
    clear_arg_type();
    set_has_int_value();
  }
  _impl_.arg_type_.int_value_ = value;
}

// double float_value = 5;
inline bool Argument::has_float_value() const {
  return arg_type_case() == kFloatValue;
}
inline void Argument::set_has_float_value() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void Argument::clear_float_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kFloatValue) {
    _impl_.arg_type_.float_value_ = 0;
    clear_has_arg_type();
  }
}
inline double Argument::float_value() const {
  // @@protoc_insertion_point(field_get:codegen.Argument.float_value)
  return _internal_float_value();
}
inline void Argument::set_float_value(double value) {
  _internal_set_float_value(value);
  // @@protoc_insertion_point(field_set:codegen.Argument.float_value)
}
inline double Argument::_internal_float_value() const {
  if (arg_type_case() == kFloatValue) {
    return _impl_.arg_type_.float_value_;
  }
  return 0;
}
inline void Argument::_internal_set_float_value(double value) {
  if (arg_type_case() != kFloatValue) {
    clear_arg_type();
    set_has_float_value();
  }
  _impl_.arg_type_.float_value_ = value;
}

// bool bool_value = 6;
inline bool Argument::has_bool_value() const {
  return arg_type_case() == kBoolValue;
}
inline void Argument::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void Argument::clear_bool_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kBoolValue) {
    _impl_.arg_type_.bool_value_ = false;
    clear_has_arg_type();
  }
}
inline bool Argument::bool_value() const {
  // @@protoc_insertion_point(field_get:codegen.Argument.bool_value)
  return _internal_bool_value();
}
inline void Argument::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:codegen.Argument.bool_value)
}
inline bool Argument::_internal_bool_value() const {
  if (arg_type_case() == kBoolValue) {
    return _impl_.arg_type_.bool_value_;
  }
  return false;
}
inline void Argument::_internal_set_bool_value(bool value) {
  if (arg_type_case() != kBoolValue) {
    clear_arg_type();
    set_has_bool_value();
  }
  _impl_.arg_type_.bool_value_ = value;
}

// string str_value = 7;
inline bool Argument::has_str_value() const {
  return arg_type_case() == kStrValue;
}
inline void Argument::set_has_str_value() {
  _impl_._oneof_case_[0] = kStrValue;
}
inline void Argument::clear_str_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kStrValue) {
    _impl_.arg_type_.str_value_.Destroy();
    clear_has_arg_type();
  }
}
inline const std::string& Argument::str_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Argument.str_value)
  return _internal_str_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Argument::set_str_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() != kStrValue) {
    clear_arg_type();

    set_has_str_value();
    _impl_.arg_type_.str_value_.InitDefault();
  }
  _impl_.arg_type_.str_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:codegen.Argument.str_value)
}
inline std::string* Argument::mutable_str_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_str_value();
  // @@protoc_insertion_point(field_mutable:codegen.Argument.str_value)
  return _s;
}
inline const std::string& Argument::_internal_str_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (arg_type_case() != kStrValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.arg_type_.str_value_.Get();
}
inline void Argument::_internal_set_str_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() != kStrValue) {
    clear_arg_type();

    set_has_str_value();
    _impl_.arg_type_.str_value_.InitDefault();
  }
  _impl_.arg_type_.str_value_.Set(value, GetArena());
}
inline std::string* Argument::_internal_mutable_str_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() != kStrValue) {
    clear_arg_type();

    set_has_str_value();
    _impl_.arg_type_.str_value_.InitDefault();
  }
  return _impl_.arg_type_.str_value_.Mutable( GetArena());
}
inline std::string* Argument::release_str_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.Argument.str_value)
  if (arg_type_case() != kStrValue) {
    return nullptr;
  }
  clear_has_arg_type();
  return _impl_.arg_type_.str_value_.Release();
}
inline void Argument::set_allocated_str_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_arg_type()) {
    clear_arg_type();
  }
  if (value != nullptr) {
    set_has_str_value();
    _impl_.arg_type_.str_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:codegen.Argument.str_value)
}

// .codegen.BoolList bool_list = 8;
inline bool Argument::has_bool_list() const {
  return arg_type_case() == kBoolList;
}
inline bool Argument::_internal_has_bool_list() const {
  return arg_type_case() == kBoolList;
}
inline void Argument::set_has_bool_list() {
  _impl_._oneof_case_[0] = kBoolList;
}
inline void Argument::clear_bool_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kBoolList) {
    if (GetArena() == nullptr) {
      delete _impl_.arg_type_.bool_list_;
    }
    clear_has_arg_type();
  }
}
inline ::codegen::BoolList* Argument::release_bool_list() {
  // @@protoc_insertion_point(field_release:codegen.Argument.bool_list)
  if (arg_type_case() == kBoolList) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.bool_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_type_.bool_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::BoolList& Argument::_internal_bool_list() const {
  return arg_type_case() == kBoolList ? *_impl_.arg_type_.bool_list_ : reinterpret_cast<::codegen::BoolList&>(::codegen::_BoolList_default_instance_);
}
inline const ::codegen::BoolList& Argument::bool_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Argument.bool_list)
  return _internal_bool_list();
}
inline ::codegen::BoolList* Argument::unsafe_arena_release_bool_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Argument.bool_list)
  if (arg_type_case() == kBoolList) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.bool_list_;
    _impl_.arg_type_.bool_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Argument::unsafe_arena_set_allocated_bool_list(::codegen::BoolList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_arg_type();
  if (value) {
    set_has_bool_list();
    _impl_.arg_type_.bool_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Argument.bool_list)
}
inline ::codegen::BoolList* Argument::_internal_mutable_bool_list() {
  if (arg_type_case() != kBoolList) {
    clear_arg_type();
    set_has_bool_list();
    _impl_.arg_type_.bool_list_ = CreateMaybeMessage<::codegen::BoolList>(GetArena());
  }
  return _impl_.arg_type_.bool_list_;
}
inline ::codegen::BoolList* Argument::mutable_bool_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::BoolList* _msg = _internal_mutable_bool_list();
  // @@protoc_insertion_point(field_mutable:codegen.Argument.bool_list)
  return _msg;
}

// .codegen.ScalarList scalar_list = 9;
inline bool Argument::has_scalar_list() const {
  return arg_type_case() == kScalarList;
}
inline bool Argument::_internal_has_scalar_list() const {
  return arg_type_case() == kScalarList;
}
inline void Argument::set_has_scalar_list() {
  _impl_._oneof_case_[0] = kScalarList;
}
inline void Argument::clear_scalar_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_type_case() == kScalarList) {
    if (GetArena() == nullptr) {
      delete _impl_.arg_type_.scalar_list_;
    }
    clear_has_arg_type();
  }
}
inline ::codegen::ScalarList* Argument::release_scalar_list() {
  // @@protoc_insertion_point(field_release:codegen.Argument.scalar_list)
  if (arg_type_case() == kScalarList) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.scalar_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_type_.scalar_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::ScalarList& Argument::_internal_scalar_list() const {
  return arg_type_case() == kScalarList ? *_impl_.arg_type_.scalar_list_ : reinterpret_cast<::codegen::ScalarList&>(::codegen::_ScalarList_default_instance_);
}
inline const ::codegen::ScalarList& Argument::scalar_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Argument.scalar_list)
  return _internal_scalar_list();
}
inline ::codegen::ScalarList* Argument::unsafe_arena_release_scalar_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Argument.scalar_list)
  if (arg_type_case() == kScalarList) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.scalar_list_;
    _impl_.arg_type_.scalar_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Argument::unsafe_arena_set_allocated_scalar_list(::codegen::ScalarList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_arg_type();
  if (value) {
    set_has_scalar_list();
    _impl_.arg_type_.scalar_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Argument.scalar_list)
}
inline ::codegen::ScalarList* Argument::_internal_mutable_scalar_list() {
  if (arg_type_case() != kScalarList) {
    clear_arg_type();
    set_has_scalar_list();
    _impl_.arg_type_.scalar_list_ = CreateMaybeMessage<::codegen::ScalarList>(GetArena());
  }
  return _impl_.arg_type_.scalar_list_;
}
inline ::codegen::ScalarList* Argument::mutable_scalar_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::ScalarList* _msg = _internal_mutable_scalar_list();
  // @@protoc_insertion_point(field_mutable:codegen.Argument.scalar_list)
  return _msg;
}

inline bool Argument::has_arg_type() const {
  return arg_type_case() != ARG_TYPE_NOT_SET;
}
inline void Argument::clear_has_arg_type() {
  _impl_._oneof_case_[0] = ARG_TYPE_NOT_SET;
}
inline Argument::ArgTypeCase Argument::arg_type_case() const {
  return Argument::ArgTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OpOverload

// string name = 1;
inline void OpOverload::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& OpOverload::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.OpOverload.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OpOverload::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:codegen.OpOverload.name)
}
inline std::string* OpOverload::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:codegen.OpOverload.name)
  return _s;
}
inline const std::string& OpOverload::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void OpOverload::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* OpOverload::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* OpOverload::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.OpOverload.name)
  return _impl_.name_.Release();
}
inline void OpOverload::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:codegen.OpOverload.name)
}

// string op = 2;
inline void OpOverload::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_.ClearToEmpty();
}
inline const std::string& OpOverload::op() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.OpOverload.op)
  return _internal_op();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OpOverload::set_op(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:codegen.OpOverload.op)
}
inline std::string* OpOverload::mutable_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:codegen.OpOverload.op)
  return _s;
}
inline const std::string& OpOverload::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.op_.Get();
}
inline void OpOverload::_internal_set_op(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_.Set(value, GetArena());
}
inline std::string* OpOverload::_internal_mutable_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.op_.Mutable( GetArena());
}
inline std::string* OpOverload::release_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.OpOverload.op)
  return _impl_.op_.Release();
}
inline void OpOverload::set_allocated_op(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.op_.IsDefault()) {
          _impl_.op_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:codegen.OpOverload.op)
}

// string target = 3;
inline void OpOverload::clear_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& OpOverload::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.OpOverload.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OpOverload::set_target(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:codegen.OpOverload.target)
}
inline std::string* OpOverload::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:codegen.OpOverload.target)
  return _s;
}
inline const std::string& OpOverload::_internal_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_.Get();
}
inline void OpOverload::_internal_set_target(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_.Set(value, GetArena());
}
inline std::string* OpOverload::_internal_mutable_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* OpOverload::release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.OpOverload.target)
  return _impl_.target_.Release();
}
inline void OpOverload::set_allocated_target(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_.IsDefault()) {
          _impl_.target_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:codegen.OpOverload.target)
}

// repeated .codegen.Argument args = 4;
inline int OpOverload::_internal_args_size() const {
  return _internal_args().size();
}
inline int OpOverload::args_size() const {
  return _internal_args_size();
}
inline void OpOverload::clear_args() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.args_.Clear();
}
inline ::codegen::Argument* OpOverload::mutable_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:codegen.OpOverload.args)
  return _internal_mutable_args()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Argument>* OpOverload::mutable_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.OpOverload.args)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_args();
}
inline const ::codegen::Argument& OpOverload::args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.OpOverload.args)
  return _internal_args().Get(index);
}
inline ::codegen::Argument* OpOverload::add_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::codegen::Argument* _add = _internal_mutable_args()->Add();
  // @@protoc_insertion_point(field_add:codegen.OpOverload.args)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Argument>& OpOverload::args() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.OpOverload.args)
  return _internal_args();
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Argument>&
OpOverload::_internal_args() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Argument>*
OpOverload::_internal_mutable_args() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.args_;
}

// map<string, .codegen.Argument> kwargs = 5;
inline int OpOverload::_internal_kwargs_size() const {
  return _internal_kwargs().size();
}
inline int OpOverload::kwargs_size() const {
  return _internal_kwargs_size();
}
inline void OpOverload::clear_kwargs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kwargs_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::codegen::Argument>& OpOverload::_internal_kwargs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kwargs_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::codegen::Argument>& OpOverload::kwargs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:codegen.OpOverload.kwargs)
  return _internal_kwargs();
}
inline ::google::protobuf::Map<std::string, ::codegen::Argument>* OpOverload::_internal_mutable_kwargs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.kwargs_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::codegen::Argument>* OpOverload::mutable_kwargs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:codegen.OpOverload.kwargs)
  return _internal_mutable_kwargs();
}

// -------------------------------------------------------------------

// OpOverloadList

// string name = 1;
inline void OpOverloadList::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& OpOverloadList::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.OpOverloadList.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OpOverloadList::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:codegen.OpOverloadList.name)
}
inline std::string* OpOverloadList::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:codegen.OpOverloadList.name)
  return _s;
}
inline const std::string& OpOverloadList::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void OpOverloadList::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* OpOverloadList::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* OpOverloadList::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:codegen.OpOverloadList.name)
  return _impl_.name_.Release();
}
inline void OpOverloadList::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:codegen.OpOverloadList.name)
}

// repeated .codegen.OpOverload op_list = 2;
inline int OpOverloadList::_internal_op_list_size() const {
  return _internal_op_list().size();
}
inline int OpOverloadList::op_list_size() const {
  return _internal_op_list_size();
}
inline void OpOverloadList::clear_op_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_list_.Clear();
}
inline ::codegen::OpOverload* OpOverloadList::mutable_op_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:codegen.OpOverloadList.op_list)
  return _internal_mutable_op_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::codegen::OpOverload>* OpOverloadList::mutable_op_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.OpOverloadList.op_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_op_list();
}
inline const ::codegen::OpOverload& OpOverloadList::op_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.OpOverloadList.op_list)
  return _internal_op_list().Get(index);
}
inline ::codegen::OpOverload* OpOverloadList::add_op_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::codegen::OpOverload* _add = _internal_mutable_op_list()->Add();
  // @@protoc_insertion_point(field_add:codegen.OpOverloadList.op_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::OpOverload>& OpOverloadList::op_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.OpOverloadList.op_list)
  return _internal_op_list();
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::OpOverload>&
OpOverloadList::_internal_op_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.op_list_;
}
inline ::google::protobuf::RepeatedPtrField<::codegen::OpOverload>*
OpOverloadList::_internal_mutable_op_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.op_list_;
}

// -------------------------------------------------------------------

// Operation

// .codegen.OpOverload op = 2;
inline bool Operation::has_op() const {
  return op_type_case() == kOp;
}
inline bool Operation::_internal_has_op() const {
  return op_type_case() == kOp;
}
inline void Operation::set_has_op() {
  _impl_._oneof_case_[0] = kOp;
}
inline void Operation::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_type_case() == kOp) {
    if (GetArena() == nullptr) {
      delete _impl_.op_type_.op_;
    }
    clear_has_op_type();
  }
}
inline ::codegen::OpOverload* Operation::release_op() {
  // @@protoc_insertion_point(field_release:codegen.Operation.op)
  if (op_type_case() == kOp) {
    clear_has_op_type();
    auto* temp = _impl_.op_type_.op_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_type_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::OpOverload& Operation::_internal_op() const {
  return op_type_case() == kOp ? *_impl_.op_type_.op_ : reinterpret_cast<::codegen::OpOverload&>(::codegen::_OpOverload_default_instance_);
}
inline const ::codegen::OpOverload& Operation::op() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Operation.op)
  return _internal_op();
}
inline ::codegen::OpOverload* Operation::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Operation.op)
  if (op_type_case() == kOp) {
    clear_has_op_type();
    auto* temp = _impl_.op_type_.op_;
    _impl_.op_type_.op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_op(::codegen::OpOverload* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op_type();
  if (value) {
    set_has_op();
    _impl_.op_type_.op_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Operation.op)
}
inline ::codegen::OpOverload* Operation::_internal_mutable_op() {
  if (op_type_case() != kOp) {
    clear_op_type();
    set_has_op();
    _impl_.op_type_.op_ = CreateMaybeMessage<::codegen::OpOverload>(GetArena());
  }
  return _impl_.op_type_.op_;
}
inline ::codegen::OpOverload* Operation::mutable_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::OpOverload* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:codegen.Operation.op)
  return _msg;
}

// .codegen.OpOverloadList fused_op = 3;
inline bool Operation::has_fused_op() const {
  return op_type_case() == kFusedOp;
}
inline bool Operation::_internal_has_fused_op() const {
  return op_type_case() == kFusedOp;
}
inline void Operation::set_has_fused_op() {
  _impl_._oneof_case_[0] = kFusedOp;
}
inline void Operation::clear_fused_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_type_case() == kFusedOp) {
    if (GetArena() == nullptr) {
      delete _impl_.op_type_.fused_op_;
    }
    clear_has_op_type();
  }
}
inline ::codegen::OpOverloadList* Operation::release_fused_op() {
  // @@protoc_insertion_point(field_release:codegen.Operation.fused_op)
  if (op_type_case() == kFusedOp) {
    clear_has_op_type();
    auto* temp = _impl_.op_type_.fused_op_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_type_.fused_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::OpOverloadList& Operation::_internal_fused_op() const {
  return op_type_case() == kFusedOp ? *_impl_.op_type_.fused_op_ : reinterpret_cast<::codegen::OpOverloadList&>(::codegen::_OpOverloadList_default_instance_);
}
inline const ::codegen::OpOverloadList& Operation::fused_op() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Operation.fused_op)
  return _internal_fused_op();
}
inline ::codegen::OpOverloadList* Operation::unsafe_arena_release_fused_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Operation.fused_op)
  if (op_type_case() == kFusedOp) {
    clear_has_op_type();
    auto* temp = _impl_.op_type_.fused_op_;
    _impl_.op_type_.fused_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_fused_op(::codegen::OpOverloadList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op_type();
  if (value) {
    set_has_fused_op();
    _impl_.op_type_.fused_op_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Operation.fused_op)
}
inline ::codegen::OpOverloadList* Operation::_internal_mutable_fused_op() {
  if (op_type_case() != kFusedOp) {
    clear_op_type();
    set_has_fused_op();
    _impl_.op_type_.fused_op_ = CreateMaybeMessage<::codegen::OpOverloadList>(GetArena());
  }
  return _impl_.op_type_.fused_op_;
}
inline ::codegen::OpOverloadList* Operation::mutable_fused_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::OpOverloadList* _msg = _internal_mutable_fused_op();
  // @@protoc_insertion_point(field_mutable:codegen.Operation.fused_op)
  return _msg;
}

// .codegen.Tensor output = 4;
inline bool Operation::has_output() const {
  return return_type_case() == kOutput;
}
inline bool Operation::_internal_has_output() const {
  return return_type_case() == kOutput;
}
inline void Operation::set_has_output() {
  _impl_._oneof_case_[1] = kOutput;
}
inline void Operation::clear_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (return_type_case() == kOutput) {
    if (GetArena() == nullptr) {
      delete _impl_.return_type_.output_;
    }
    clear_has_return_type();
  }
}
inline ::codegen::Tensor* Operation::release_output() {
  // @@protoc_insertion_point(field_release:codegen.Operation.output)
  if (return_type_case() == kOutput) {
    clear_has_return_type();
    auto* temp = _impl_.return_type_.output_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.return_type_.output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::Tensor& Operation::_internal_output() const {
  return return_type_case() == kOutput ? *_impl_.return_type_.output_ : reinterpret_cast<::codegen::Tensor&>(::codegen::_Tensor_default_instance_);
}
inline const ::codegen::Tensor& Operation::output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Operation.output)
  return _internal_output();
}
inline ::codegen::Tensor* Operation::unsafe_arena_release_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Operation.output)
  if (return_type_case() == kOutput) {
    clear_has_return_type();
    auto* temp = _impl_.return_type_.output_;
    _impl_.return_type_.output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_output(::codegen::Tensor* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_return_type();
  if (value) {
    set_has_output();
    _impl_.return_type_.output_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Operation.output)
}
inline ::codegen::Tensor* Operation::_internal_mutable_output() {
  if (return_type_case() != kOutput) {
    clear_return_type();
    set_has_output();
    _impl_.return_type_.output_ = CreateMaybeMessage<::codegen::Tensor>(GetArena());
  }
  return _impl_.return_type_.output_;
}
inline ::codegen::Tensor* Operation::mutable_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::Tensor* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:codegen.Operation.output)
  return _msg;
}

// .codegen.TensorList outputs = 5;
inline bool Operation::has_outputs() const {
  return return_type_case() == kOutputs;
}
inline bool Operation::_internal_has_outputs() const {
  return return_type_case() == kOutputs;
}
inline void Operation::set_has_outputs() {
  _impl_._oneof_case_[1] = kOutputs;
}
inline void Operation::clear_outputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (return_type_case() == kOutputs) {
    if (GetArena() == nullptr) {
      delete _impl_.return_type_.outputs_;
    }
    clear_has_return_type();
  }
}
inline ::codegen::TensorList* Operation::release_outputs() {
  // @@protoc_insertion_point(field_release:codegen.Operation.outputs)
  if (return_type_case() == kOutputs) {
    clear_has_return_type();
    auto* temp = _impl_.return_type_.outputs_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.return_type_.outputs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::codegen::TensorList& Operation::_internal_outputs() const {
  return return_type_case() == kOutputs ? *_impl_.return_type_.outputs_ : reinterpret_cast<::codegen::TensorList&>(::codegen::_TensorList_default_instance_);
}
inline const ::codegen::TensorList& Operation::outputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Operation.outputs)
  return _internal_outputs();
}
inline ::codegen::TensorList* Operation::unsafe_arena_release_outputs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:codegen.Operation.outputs)
  if (return_type_case() == kOutputs) {
    clear_has_return_type();
    auto* temp = _impl_.return_type_.outputs_;
    _impl_.return_type_.outputs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Operation::unsafe_arena_set_allocated_outputs(::codegen::TensorList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_return_type();
  if (value) {
    set_has_outputs();
    _impl_.return_type_.outputs_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:codegen.Operation.outputs)
}
inline ::codegen::TensorList* Operation::_internal_mutable_outputs() {
  if (return_type_case() != kOutputs) {
    clear_return_type();
    set_has_outputs();
    _impl_.return_type_.outputs_ = CreateMaybeMessage<::codegen::TensorList>(GetArena());
  }
  return _impl_.return_type_.outputs_;
}
inline ::codegen::TensorList* Operation::mutable_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::codegen::TensorList* _msg = _internal_mutable_outputs();
  // @@protoc_insertion_point(field_mutable:codegen.Operation.outputs)
  return _msg;
}

inline bool Operation::has_op_type() const {
  return op_type_case() != OP_TYPE_NOT_SET;
}
inline void Operation::clear_has_op_type() {
  _impl_._oneof_case_[0] = OP_TYPE_NOT_SET;
}
inline bool Operation::has_return_type() const {
  return return_type_case() != RETURN_TYPE_NOT_SET;
}
inline void Operation::clear_has_return_type() {
  _impl_._oneof_case_[1] = RETURN_TYPE_NOT_SET;
}
inline Operation::OpTypeCase Operation::op_type_case() const {
  return Operation::OpTypeCase(_impl_._oneof_case_[0]);
}
inline Operation::ReturnTypeCase Operation::return_type_case() const {
  return Operation::ReturnTypeCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Model

// repeated .codegen.Tensor inputs = 1;
inline int Model::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int Model::inputs_size() const {
  return _internal_inputs_size();
}
inline void Model::clear_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inputs_.Clear();
}
inline ::codegen::Tensor* Model::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:codegen.Model.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Tensor>* Model::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.Model.inputs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_inputs();
}
inline const ::codegen::Tensor& Model::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Model.inputs)
  return _internal_inputs().Get(index);
}
inline ::codegen::Tensor* Model::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::codegen::Tensor* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:codegen.Model.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>& Model::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.Model.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>&
Model::_internal_inputs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Tensor>*
Model::_internal_mutable_inputs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.inputs_;
}

// repeated .codegen.Tensor parameters = 2;
inline int Model::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int Model::parameters_size() const {
  return _internal_parameters_size();
}
inline void Model::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline ::codegen::Tensor* Model::mutable_parameters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:codegen.Model.parameters)
  return _internal_mutable_parameters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Tensor>* Model::mutable_parameters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.Model.parameters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_parameters();
}
inline const ::codegen::Tensor& Model::parameters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Model.parameters)
  return _internal_parameters().Get(index);
}
inline ::codegen::Tensor* Model::add_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::codegen::Tensor* _add = _internal_mutable_parameters()->Add();
  // @@protoc_insertion_point(field_add:codegen.Model.parameters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>& Model::parameters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.Model.parameters)
  return _internal_parameters();
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Tensor>&
Model::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_;
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Tensor>*
Model::_internal_mutable_parameters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.parameters_;
}

// repeated .codegen.Operation ops = 3;
inline int Model::_internal_ops_size() const {
  return _internal_ops().size();
}
inline int Model::ops_size() const {
  return _internal_ops_size();
}
inline void Model::clear_ops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ops_.Clear();
}
inline ::codegen::Operation* Model::mutable_ops(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:codegen.Model.ops)
  return _internal_mutable_ops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Operation>* Model::mutable_ops()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:codegen.Model.ops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ops();
}
inline const ::codegen::Operation& Model::ops(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:codegen.Model.ops)
  return _internal_ops().Get(index);
}
inline ::codegen::Operation* Model::add_ops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::codegen::Operation* _add = _internal_mutable_ops()->Add();
  // @@protoc_insertion_point(field_add:codegen.Model.ops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Operation>& Model::ops() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:codegen.Model.ops)
  return _internal_ops();
}
inline const ::google::protobuf::RepeatedPtrField<::codegen::Operation>&
Model::_internal_ops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ops_;
}
inline ::google::protobuf::RepeatedPtrField<::codegen::Operation>*
Model::_internal_mutable_ops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ops_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace codegen


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_param_2eproto_2epb_2eh
